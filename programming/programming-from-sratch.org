#+TITLE: Studing Programming From Scratch
#+AUTHOR: Zhengnan Ma(MZN)
#+OPTIONS: toc:2

* Table Of Contents :toc:
- [[#programming-languages-i-want-to-learn][Programming languages I want to learn]]
- [[#plan-and-studing-methods][Plan and studing methods]]
- [[#course-and-books][Course and books]]
  - [[#introduce][Introduce]]
  - [[#detail][Detail]]
- [[#7-coding-projects][7 coding projects]]
  - [[#a-ray-tracer][A Ray Tracer]]
  - [[#an-operating-system][An Operating System]]
  - [[#an-emulator][An Emulator]]
  - [[#an-interpreter][An Interpreter]]
  - [[#web-server][Web Server]]
  - [[#a-neural-network][A Neural Network]]
  - [[#a-blockchain][A Blockchain]]
- [[#cs-self-learning][CS Self Learning]]

* Programming languages I want to learn
+ c
+ c++
+ go
+ rust
+ python
+ css + html + javascript

* Plan and studing methods 
1. æŒæ¡äº†ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µï¼šä»–ä»¬å·²ç»ç†è§£äº†å˜é‡ã€æ•°æ®ç»“æ„ã€æ§åˆ¶æµã€é¢å‘å¯¹è±¡ã€å‡½æ•°å¼ç¼–ç¨‹ç­‰æ ¸å¿ƒæ€æƒ³ï¼Œæ— è®ºæ¢ä»€ä¹ˆè¯­è¨€ï¼Œè¿™äº›æ¦‚å¿µéƒ½æ˜¯é€šç”¨çš„ã€‚
2. ç†Ÿæ‚‰è®¡ç®—æœºåŸºç¡€ï¼šæŒæ¡è®¡ç®—æœºç³»ç»Ÿã€å†…å­˜ç®¡ç†ã€å¹¶å‘ã€ç®—æ³•ç­‰åŸºç¡€çŸ¥è¯†ï¼Œè®©ä»–ä»¬èƒ½å¿«é€Ÿé€‚åº”æ–°è¯­è¨€çš„åº•å±‚å®ç°ã€‚
3. æœ‰è·¨è¯­è¨€ç»éªŒï¼šå¤šå­¦å‡ é—¨è¯­è¨€åï¼Œä»–ä»¬ä¼šå‘ç°å¾ˆå¤šè¯­è¨€çš„æ¨¡å¼å’Œç‰¹æ€§æ˜¯ç±»ä¼¼çš„ï¼Œæ¯”å¦‚ Pythonã€JavaScript å’Œ Rust éƒ½æœ‰é—­åŒ…ã€æ³›å‹ï¼ˆæŸç§ç¨‹åº¦ä¸Šï¼‰ç­‰æ¦‚å¿µã€‚
4. å–„äºé˜…è¯»å®˜æ–¹æ–‡æ¡£ï¼šä»–ä»¬çŸ¥é“å¦‚ä½•é«˜æ•ˆæŸ¥é˜…æ–‡æ¡£ï¼Œè€Œä¸æ˜¯æ­»è®°ç¡¬èƒŒè¯­æ³•ã€‚
5. æ³¨é‡å®æˆ˜ï¼šä»–ä»¬å­¦æ–°è¯­è¨€æ—¶ï¼Œé€šå¸¸ä¼šç›´æ¥å†™å°é¡¹ç›®ï¼Œè€Œä¸æ˜¯åªå­¦è¯­æ³•ã€‚

* Course and books
** Introduce
1. è®¡ç®—æœºç§‘å­¦åŸºç¡€
    +  CS50: Introduction to Computer Scienceï¼ˆå“ˆä½›å¤§å­¦å…¬å¼€è¯¾ï¼Œé€‚åˆåˆå­¦è€…ï¼‰[[https://www.edx.org/cs50][links]]
    + ã€Šè®¡ç®—æœºç¨‹åºçš„æ„é€ å’Œè§£é‡Šã€‹ï¼ˆSICPï¼‰ï¼ˆä¸»è¦ç”¨ Schemeï¼Œä½†è®²è§£ç¼–ç¨‹æ€æƒ³éå¸¸æ·±åˆ»ï¼‰
2. ç¼–ç¨‹èŒƒå¼ï¼ˆæ€ç»´æ¨¡å¼ï¼‰
    + ã€Šä»£ç å¤§å…¨ã€‹ï¼ˆCode Completeï¼Œè®²è§£è½¯ä»¶å¼€å‘ä¸­çš„ç¼–ç¨‹æŠ€å·§å’Œæœ€ä½³å®è·µï¼‰
    + ã€Šç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…»ã€‹ï¼ˆæ¶‰åŠåº•å±‚çŸ¥è¯†ï¼Œå¸®åŠ©ç†è§£è®¡ç®—æœºåŸç†ï¼‰
    + ã€Šç¼–ç¨‹èŒƒå¼ï¼šå‡½æ•°å¼ã€å‘½ä»¤å¼ä¸å¹¶å‘ç¼–ç¨‹ã€‹ï¼ˆä»‹ç»ä¸åŒçš„ç¼–ç¨‹æ€ç»´ï¼‰
3. æ•°æ®ç»“æ„ä¸ç®—æ³•ï¼ˆè·¨è¯­è¨€é€šç”¨ï¼‰
    + ã€Šç®—æ³•å¯¼è®ºã€‹ï¼ˆIntroduction to Algorithmsï¼Œåç†è®ºï¼‰
    + LeetCodeï¼ˆå®é™…ç¼–ç¨‹è®­ç»ƒï¼Œæé«˜é€»è¾‘æ€ç»´èƒ½åŠ›ï¼‰
    + MIT å…¬å¼€è¯¾ã€Šç®—æ³•ã€‹

** Detail
å­¦ä¹ è®¡ç®—æœºåŸºç¡€ã€æ•°æ®ç»“æ„ã€ç®—æ³•å’Œç¼–ç¨‹èŒƒå¼åï¼Œèƒ½å¦æ·±åˆ»ç†è§£å¹¶å‘ã€é—­åŒ…ç­‰æ¦‚å¿µï¼Ÿ
æ˜¯çš„ï¼Œå­¦ä¹ äº†è¿™äº›åŸºç¡€çŸ¥è¯†åï¼Œä½ ä¼šæ›´å®¹æ˜“ç†è§£å¹¶å‘ã€é—­åŒ…ç­‰æ¦‚å¿µï¼Œä½†è¦çœŸæ­£æ·±åˆ»ç†è§£ï¼Œä»ç„¶éœ€è¦ä¸“é—¨å­¦ä¹ å®ƒä»¬çš„åŸç†å’Œåº”ç”¨ã€‚

é—­åŒ…ï¼šæœ¬è´¨ä¸Šæ˜¯å‡½æ•°æºå¸¦ä¸Šä¸‹æ–‡ç¯å¢ƒï¼ˆå˜é‡æ•è·ï¼‰ï¼Œä¸»è¦æ¶‰åŠä½œç”¨åŸŸã€ç”Ÿå‘½å‘¨æœŸã€å †æ ˆåˆ†é…ç­‰æ¦‚å¿µã€‚ç†è§£ å‡½æ•°å¼ç¼–ç¨‹ã€ä½œç”¨åŸŸé“¾ ä¹‹åï¼Œé—­åŒ…å°±å®¹æ˜“ç†è§£äº†ã€‚
å¹¶å‘ï¼šæœ¬è´¨æ˜¯å¤šä¸ªä»»åŠ¡åŒæ—¶æ‰§è¡Œï¼Œæ¶‰åŠ çº¿ç¨‹ã€è¿›ç¨‹ã€åç¨‹ã€å¼‚æ­¥ç¼–ç¨‹ã€å†…å­˜æ¨¡å‹ ç­‰æ¦‚å¿µï¼Œå­¦ä¹  æ“ä½œç³»ç»Ÿã€è®¡ç®—æœºä½“ç³»ç»“æ„ åç†è§£ä¼šæ›´æ·±å…¥ã€‚
å› æ­¤ï¼Œè®¡ç®—æœºåŸºç¡€ + ç®—æ³• + ç¼–ç¨‹èŒƒå¼ èƒ½è®©ä½ æ‰“å¥½ç†è§£çš„åŸºç¡€ï¼Œä½†å¦‚æœæƒ³ç²¾é€šå¹¶å‘ã€é—­åŒ…ç­‰ï¼Œéœ€è¦é¢å¤–å­¦ä¹ ç›¸å…³è¯¾ç¨‹ã€‚

è¯¾ç¨‹æ¨èï¼ˆæŒ‰æ¦‚å¿µåˆ†ç±»ï¼‰
1. è®¡ç®—æœºåŸºç¡€ï¼ˆæ‰“å¥½ç¼–ç¨‹åº•å±‚åŸºç¡€ï¼‰
CS50: Introduction to Computer Scienceï¼ˆå“ˆä½›å…¬å¼€è¯¾ï¼Œåˆå­¦è€…å‹å¥½ï¼‰
ã€Šè®¡ç®—æœºç³»ç»Ÿè¦ç´ ã€‹ï¼ˆNand2Tetrisï¼Œé€‚åˆæƒ³æ·±å…¥ç†è§£è®¡ç®—æœºè¿è¡ŒåŸç†çš„äººï¼‰
ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹CSAPPï¼ˆComputer Systems: A Programmer's Perspectiveï¼‰ï¼ˆå¼ºçƒˆæ¨èï¼Œè®²å†…å­˜ã€ç¼“å­˜ã€å¹¶å‘ã€ç¼–è¯‘åŸç†ï¼‰
2. ç¼–ç¨‹èŒƒå¼ï¼ˆå‡½æ•°å¼ã€å‘½ä»¤å¼ã€é¢å‘å¯¹è±¡ï¼‰
ã€Šè®¡ç®—æœºç¨‹åºçš„æ„é€ å’Œè§£é‡Šã€‹ï¼ˆSICPï¼‰ï¼ˆä¸»è¦ç”¨ Schemeï¼Œä½†è®²è§£ç¼–ç¨‹æ€æƒ³éå¸¸æ·±åˆ»ï¼‰
ã€Šä»£ç å¤§å…¨ã€‹ï¼ˆCode Completeï¼Œè®²è§£è½¯ä»¶å¼€å‘ä¸­çš„ç¼–ç¨‹æŠ€å·§å’Œæœ€ä½³å®è·µï¼‰
ã€ŠJavaScript ä½ ä¸çŸ¥é“çš„é‚£ç‚¹äº‹ã€‹ï¼ˆè®²ä½œç”¨åŸŸã€é—­åŒ…ã€åŸå‹é“¾ï¼Œé€‚åˆç†è§£åŠ¨æ€è¯­è¨€çš„ç¼–ç¨‹æ€æƒ³ï¼‰
Functional Programming in Scalaï¼ˆæ·±å…¥ç†è§£å‡½æ•°å¼ç¼–ç¨‹ï¼‰
3. æ•°æ®ç»“æ„ & ç®—æ³•ï¼ˆé‡ç‚¹å†…å®¹ + ç²¾ç®€å­¦ä¹ ï¼‰
æ•°æ®ç»“æ„å’Œç®—æ³•çš„å­¦ä¹ é‡ç¡®å®å¾ˆå¤§ï¼Œä½†æ ¸å¿ƒå†…å®¹å¹¶ä¸å¤šã€‚ä»¥ä¸‹æ˜¯å¿…å­¦çš„éƒ¨åˆ†ï¼Œå·¥ä½œä¸­æœ€å¸¸ç”¨ï¼š

â— å¿…å­¦æ•°æ®ç»“æ„ï¼ˆç”¨é€”å¹¿ï¼Œå·¥ä½œä¸­æœ€å¸¸è§ï¼‰
æ•°ç»„ & é“¾è¡¨ï¼ˆåŸºç¡€æ•°æ®ç»“æ„ï¼‰
æ ˆ & é˜Ÿåˆ—ï¼ˆå¦‚æ‹¬å·åŒ¹é…ã€ä»»åŠ¡è°ƒåº¦ï¼‰
å“ˆå¸Œè¡¨ï¼ˆæŸ¥æ‰¾ã€å»é‡ã€ç¼“å­˜ï¼‰
äºŒå‰æ ‘ & äºŒå‰æœç´¢æ ‘ï¼ˆéå†ã€æœç´¢ã€æ•°æ®åº“ç´¢å¼•ï¼‰
å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¸¸ç”¨äºè°ƒåº¦ã€ç¼“å­˜æ·˜æ±°ï¼‰
å›¾ï¼ˆæ‹“æ‰‘æ’åºã€æœ€çŸ­è·¯å¾„ï¼Œé€‚ç”¨äºä¾èµ–è§£æã€å¯¼èˆªï¼‰
â— å¿…å­¦ç®—æ³•ï¼ˆå·¥ä½œä¸­å¸¸ç”¨ï¼Œé¢è¯•å¿…å¤‡ï¼‰
æ’åºç®—æ³•ï¼ˆå¿«æ’ã€å½’å¹¶ã€å †æ’åºâ€”â€”æŒæ¡å¿«æ’å’Œå †æ’å³å¯ï¼‰
äºŒåˆ†æŸ¥æ‰¾ï¼ˆæœ‰åºæ•°æ®æŸ¥æ‰¾çš„é«˜æ•ˆæ–¹æ³•ï¼‰
åŒæŒ‡é’ˆï¼ˆé“¾è¡¨é—®é¢˜ã€æ•°ç»„å»é‡ç­‰ï¼‰
å“ˆå¸ŒæŸ¥æ‰¾ï¼ˆå»é‡ã€è®¡æ•°ï¼‰
æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ & å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ï¼ˆéå†å›¾ã€æ ‘ç»“æ„ï¼ŒAIæœç´¢ï¼‰
åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰ï¼ˆæ–æ³¢é‚£å¥‘ã€èƒŒåŒ…é—®é¢˜ã€å­åºåˆ—é—®é¢˜ç­‰ï¼‰
Dijkstra æœ€çŸ­è·¯å¾„ç®—æ³•ï¼ˆå›¾è®ºä¸­çš„å¸¸è§é—®é¢˜ï¼‰
æ‹“æ‰‘æ’åºï¼ˆä¾èµ–å…³ç³»è§£æï¼Œå¦‚ä»»åŠ¡è°ƒåº¦ï¼‰
æ¨èå­¦ä¹ èµ„æº
MIT 6.006 - Introduction to Algorithmsï¼ˆç®—æ³•å…¥é—¨ï¼Œè®²è§£å¾ˆæ¸…æ™°ï¼‰
ã€Šç®—æ³•å¯¼è®ºã€‹ï¼ˆIntroduction to Algorithmsï¼Œé€‚åˆç³»ç»Ÿå­¦ä¹ ï¼Œä½†è¾ƒåšï¼Œå»ºè®®æŒ‰éœ€å­¦ä¹ ï¼‰
ã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹ï¼ˆæ›´æ˜“è¯»ï¼Œé€‚åˆç¼–ç¨‹å®è·µï¼‰
LeetCode ç»å…¸ 100 é¢˜ï¼ˆå·¥ä½œä¸­å¸¸è§çš„ç®—æ³•é—®é¢˜ï¼‰
4. å¹¶å‘ç¼–ç¨‹ï¼ˆé‡ç‚¹å­¦ä¹ æ“ä½œç³»ç»Ÿ + è¯­è¨€å¹¶å‘æœºåˆ¶ï¼‰
â— å¹¶å‘çš„æ ¸å¿ƒæ¦‚å¿µï¼š

è¿›ç¨‹ vs çº¿ç¨‹ï¼ˆçº¿ç¨‹å…±äº«å†…å­˜ï¼Œè¿›ç¨‹éš”ç¦»ï¼‰
çº¿ç¨‹åŒæ­¥ & äº’æ–¥é”ï¼ˆé¿å…æ•°æ®ç«äº‰ï¼‰
çº¿ç¨‹æ±  & ä»»åŠ¡è°ƒåº¦ï¼ˆé«˜æ•ˆç®¡ç†å¹¶å‘ä»»åŠ¡ï¼‰
å¼‚æ­¥ç¼–ç¨‹ï¼ˆasync/await, event loopï¼‰ï¼ˆRustã€Pythonã€JavaScript éƒ½æœ‰ï¼‰
å†…å­˜æ¨¡å‹ & åŸå­æ“ä½œï¼ˆæ·±å…¥ç†è§£å¹¶å‘ï¼‰
ğŸ“š æ¨èå­¦ä¹ èµ„æº

MIT 6.824 - Distributed Systemsï¼ˆå“ˆä½› MIT è¯¾ç¨‹ï¼Œåˆ†å¸ƒå¼å¹¶å‘ç¼–ç¨‹ï¼‰
ã€Šç°ä»£æ“ä½œç³»ç»Ÿã€‹ï¼ˆå¹¶å‘çš„åŸºç¡€çŸ¥è¯†ï¼Œæ·±å…¥ç†è§£è¿›ç¨‹ã€çº¿ç¨‹ã€é”ï¼‰
ã€ŠJava å¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹ï¼ˆé€‚ç”¨äº Java ä½†é€šç”¨ï¼‰
ã€ŠGo è¯­è¨€å¹¶å‘ç¼–ç¨‹ã€‹ï¼ˆå¦‚æœä½¿ç”¨ Goï¼‰
Rust å¹¶å‘å®˜æ–¹æ–‡æ¡£ï¼ˆRust å¼ºè°ƒçº¿ç¨‹å®‰å…¨ï¼‰
5. é—­åŒ…ï¼ˆä½œç”¨åŸŸ + å‡½æ•°å¼ç¼–ç¨‹ï¼‰
â— å…³é”®çŸ¥è¯†ç‚¹ï¼š

å˜é‡æ•è· & ä½œç”¨åŸŸï¼ˆé—­åŒ…ä¿ç•™åˆ›å»ºæ—¶çš„ä½œç”¨åŸŸï¼‰
ç”Ÿå‘½å‘¨æœŸï¼ˆç‰¹åˆ«æ˜¯ Rustï¼‰ï¼ˆé¿å…æ‚¬ç©ºå¼•ç”¨ï¼‰
é«˜é˜¶å‡½æ•° & å‡½æ•°å¼ç¼–ç¨‹ï¼ˆé—­åŒ…çš„ä¸»è¦åº”ç”¨åœºæ™¯ï¼‰
ğŸ“š æ¨èå­¦ä¹ èµ„æº

Eloquent JavaScriptï¼ˆJavaScript ç‰ˆï¼‰ï¼ˆæ·±å…¥ç†è§£é—­åŒ…ï¼‰
ã€ŠJavaScript ä½ ä¸çŸ¥é“çš„é‚£ç‚¹äº‹ã€‹ï¼ˆä½œç”¨åŸŸé“¾ã€é—­åŒ…ï¼‰
ã€ŠFunctional Programming in Scalaã€‹ï¼ˆæ·±å…¥ç†è§£é—­åŒ…å’Œå‡½æ•°å¼ç¼–ç¨‹ï¼‰
Rust å®˜æ–¹æ–‡æ¡£ï¼ˆé—­åŒ… & ç”Ÿå‘½å‘¨æœŸï¼‰
æ€»ç»“ï¼šå¦‚ä½•ç²¾ç®€å­¦ä¹ ï¼Ÿ
è®¡ç®—æœºåŸºç¡€ï¼š

CS50ï¼ˆåˆå­¦è€…ï¼‰ or CSAPPï¼ˆæ·±å…¥ç†è§£ï¼‰
ç¼–ç¨‹èŒƒå¼ï¼š

SICPï¼ˆè®¡ç®—æœºç¼–ç¨‹æ€æƒ³ï¼‰ or Code Completeï¼ˆå·¥ç¨‹å®è·µï¼‰
æ•°æ®ç»“æ„ & ç®—æ³•ï¼š

åªå­¦ï¼šæ•°ç»„ã€å“ˆå¸Œè¡¨ã€æ ‘ã€å †ã€å›¾
åªå­¦ï¼šå¿«æ’ã€äºŒåˆ†ã€BFSã€DFSã€åŠ¨æ€è§„åˆ’ã€Dijkstra
èµ„æºï¼šMIT 6.006 + LeetCode 100 é¢˜
å¹¶å‘ç¼–ç¨‹ï¼š

æ“ä½œç³»ç»ŸåŸºç¡€ï¼ˆè¿›ç¨‹ã€çº¿ç¨‹ã€é”ï¼‰
è¯­è¨€ç‰¹æ€§ï¼ˆRustã€Goã€Python å¹¶å‘ï¼‰
èµ„æºï¼šMIT 6.824 + ç°ä»£æ“ä½œç³»ç»Ÿ
é—­åŒ…ï¼š

ä½œç”¨åŸŸé“¾ã€å˜é‡æ•è·ã€é«˜é˜¶å‡½æ•°
èµ„æºï¼šã€ŠJavaScript ä½ ä¸çŸ¥é“çš„é‚£ç‚¹äº‹ã€‹+ Rust å®˜æ–¹æ–‡æ¡£

* 7 coding projects
[[https://medium.com/@keyvank/7-coding-projects-every-programming-hobbyist-should-write-before-his-death-79d931cf4192][7 coding projects every programming hobbyist should write before his death]] by [[https://medium.com/@keyvank][Keyvan Kambakhsh]].
And his [[https://github.com/keyvank][github homepage]] is intresting!
** A Ray Tracer
Ray Tracing doesnâ€™t completely implement the [[https://en.wikipedia.org/wiki/Rendering_equation][Rendering Equation]] but it is a very good start for learning other more advanced rendering algorithms. You can read more about it [[https://en.wikipedia.org/wiki/Ray_tracing_(graphics)][Wikipedia]].

By developing a 3D renderer, you will learn:
+ How all those 3D animations are built.
+ How parallel programming can help us with problems like this.
+ Linear algebra, 3D math, matrices and why you should take your math classes seriously!
+ (Bonus!) BSP trees if you are tired of rendering spheres and you want something more.

*Related algorithm*
+ [[https://en.wikipedia.org/wiki/Path_tracing][Path Tracing]] that will completely implement the rendering equation and gives you results that are indistinguishable from reality.
+ [[https://en.wikipedia.org/wiki/Rasterisation][Rasterisation]] which is the algorithm used in games for generating real-time 3D.

*Demo*
+ [[https://github.com/keyvank/pyglare][pyglare]]
+ [[https://www.kevinbeason.com/smallpt/][smallpt]]

*Useful link*
+ [[https://www.scratchapixel.com/][scratchapixel]]

** An Operating System
By developing an OS you will learn:
+ How your computer boots up from the time you press the power key.
+ How Operating Systems manage multiple processes.
+ How programs are protected from modifying each other.
+ How files are stored on the disk.
+ What linkers and loaders are and how they work.
+ Low level stuff!

*Toturial*
+ [[https://github.com/cfenollosa/os-tutorial][os-tutorial]] gives you a very great introduction on how to write your own OS using C programming language.
+ [[https://github.com/keyvank/zincos][zincos]] is a simple operating system which has multitasking, userland, and paging, which is written in C++11.
+ [[http://www.brokenthorn.com/Resources/OSDevIndex.html][Operating System Development Series]] is super and [[https://wiki.osdev.org/Expanded_Main_Page][OSDev Wiki]] as its reference manual.

** An Emulator
So, having written the shiny brand new Operating System in the previous step and bing now fluent in talking with iron. Next step is to emulate the iron itself! There are plenty of great hardware out there that you can emulate. You can start with simpler ones like =CHIP-8= and move further by implementing a complete =NES= emulator, like the video below!
  
By developing emulators you will learn:
+ Computer Architecture
+ Different design strategies in different hardware.
+ Instruction set of the target machine.

*Tutorial*
+ [[https://en.wikipedia.org/wiki/CHIP-8][CHIP-8]]
+ [[https://yizhang82.dev/nes-emu-overview][NES]]
+ [[https://www.youtube.com/watch?v=XZWw745wPXY][Creating a NES emulator in C++11]]
+ [[https://www.youtube.com/user/Bisqwit][Bisqwit's Youtube Channel]]


** An Interpreter
/If you donâ€™t know how compilers work, then you donâ€™t know how computers work. If youâ€™re not 100% sure whether you know how compilers work, then you donâ€™t know how they work. (Steve Yegge)/

Coding with your own language would be really satisfying. [[https://ruslanspivak.com/][Ruslan Spivak]] has a great tutorial series on how to write an interpreter in Python. In this series you will implement an interpreter for Pascal programming language from scratch. You will start by implementing a [[https://en.wikipedia.org/wiki/Lexical_analysis][lexical analyzer]] and [[https://en.wikipedia.org/wiki/Parsing#Computer_languages][parser]] for it, and will move further by implementing different features of Pascal language.

If you want something simpler and more fun, [[https://norvig.com/][Peter Norvig]] has an article on [[https://norvig.com/lispy.html][(How to Write a (Lisp) Interpreter (in Python))]]. Lisp is a functional programming language. As Lisp has a very simple syntax, it would be easy to write a lexical scanner and parser for it and therefore it is a very good start for learning how interpreters work. If you have not tried functional programming languages before, you will also get a taste of functional programming too. 

If you are brave enough, you can also try implementing a Compiler too. Start with implementing a C compiler which is able to compile itself! Check out [[https://github.com/rui314/8cc][this project]]. His author has tried to implement a minimal C compiler which supports all C11 language features while keeping the code as small and simple as possible.

By writing an interpreter/compiler you will learn:
+ Writing lexical analyzers & parsers by yourself and using tools developed for this purpose.
+ Implementing interpreters.
+ Code generation and compilers.
+ (Bonus!) Functional programming if you followed the second tutorial :)

** Web Server
The process is like:
   1. Your operating system resolves the IP address of that domain by asking DNS servers, there is a great illustration of this process here(The websit is unknown)!
   2. Your browser asks port 80 of that particular IP address to send its HTML content to us.
   3. Your browser renders the response on the screen.
So you are going to implement the second step of this process. For that, you should learn a little bit about Socket programming in the language you are coding with, listen to the port 80 of your network interface, return HTML contents according to the URL the client is requesting.

Your Web Server should be able to:
+ Take a root directory in its config file and respond with HTML content according to the URL the client is requesting.
+ Respond with files.
+ (Bonus!) Provide an interface for programmers to develop dynamic web applications with.

  
** A Neural Network
Deep learning is a trending topic today. Start by learning the backpropagation algorithm, used for simple feed-forward neural networks. Then try to build a network that is capable of learning the MNIST database. You will end up developing a software that is able to recognize handwritten digits!

[[https://venelinvalkov.medium.com/tensorflow-for-hackers-part-iv-neural-network-from-scratch-1a4f504dfa8][Creating a Neural Network from Scratch]] is a great article by [[https://venelinvalkov.medium.com/][Venelin Valkov]] that teaches you how to build a vanilla Neural Network from scratch in Python without using tools like TensorFlow.

By implementing a neural network you will learn:
+ How multiple layers of simple neurons can learn complex representations.
+ The building blocks of Neural Networks and Deep Learning.
+ GPGPU programming if you want to do something more serious.

** A Blockchain
Blockchains are fun. Before getting started, I highly recommend you to read the famous [[https://bitcoin.org/bitcoin.pdf][Bitcoin Whitepaper]].

Donâ€™t get me wrong. I am not telling you to create another fork of Litecoin or whatever scam shit. But you should really understand how all those cryptocurrencies work. They are genius, they have many brilliant ideas underneath. Learn blockchains by creating them from scratch, there is a great article on this [[https://cranklin.wordpress.com/2017/07/11/lets-create-our-own-cryptocurrency/][here]]!

You can also have your coin listed on exchanges if your project has something new to provide!

By implementing a blockchain you will learn:
+ Cryptography stuff like hash functions, public/private keys and etc.
+ How P2P applications are implemented.
+ How to create consensus in a network with some brilliant ideas like PoW / PoS.

* CS Self Learning 
[[https://csdiy.wiki/][The book for learning cs by self]].
[[https://github.com/Tikam02/DevOps-Guide][Maybe like a dictionary on programming]].
